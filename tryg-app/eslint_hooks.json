[{"filePath":"C:\\Users\\dinko\\Projects\\PNWS\\tryg-app\\src\\hooks\\useAuth.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1827,1830],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1827,1830],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":107,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4251,4254],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4251,4254],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":119,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4637,4640],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4637,4640],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":142,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":142,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5440,5443],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5440,5443],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":153,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5702,5705],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5702,5705],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":166,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6119,6122],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6119,6122],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":182,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":182,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6627,6630],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6627,6630],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":197,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7128,7131],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7128,7131],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":208,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7433,7436],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7433,7436],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback } from 'react';\r\nimport {\r\n    onAuthStateChanged,\r\n    signInWithEmailAndPassword,\r\n    createUserWithEmailAndPassword,\r\n    signInWithPopup,\r\n    GoogleAuthProvider,\r\n    signOut as firebaseSignOut,\r\n    updateProfile,\r\n    sendPasswordResetEmail,\r\n    User\r\n} from 'firebase/auth';\r\nimport { doc, setDoc, getDoc, serverTimestamp } from 'firebase/firestore';\r\nimport { auth, db } from '../config/firebase';\r\nimport { UserProfile } from '../types';\r\n\r\nconst googleProvider = new GoogleAuthProvider();\r\n\r\nexport function useAuth() {\r\n    const [user, setUser] = useState<User | null>(null);\r\n    const [userProfile, setUserProfile] = useState<UserProfile | null>(null);\r\n    const [loading, setLoading] = useState(true);\r\n    const [error, setError] = useState<string | null>(null);\r\n\r\n    // Listen for auth state changes\r\n    useEffect(() => {\r\n        const unsubscribe = onAuthStateChanged(auth, async (firebaseUser: User | null) => {\r\n            setUser(firebaseUser);\r\n\r\n            if (firebaseUser) {\r\n                // Fetch user profile from Firestore with retry logic\r\n                // Firestore may not be ready when auth fires from cache\r\n                const fetchProfileWithRetry = async (retries = 3, delay = 500) => {\r\n                    for (let attempt = 1; attempt <= retries; attempt++) {\r\n                        try {\r\n                            const profileDoc = await getDoc(doc(db, 'users', firebaseUser.uid));\r\n                            if (profileDoc.exists()) {\r\n                                setUserProfile(profileDoc.data() as UserProfile);\r\n                                setError(null); // Clear any previous error\r\n                            }\r\n                            return; // Success, exit\r\n                        } catch (err: any) {\r\n                            console.error(`Error fetching user profile (attempt ${attempt}/${retries}):`, err);\r\n\r\n                            // If offline error and we have retries left, wait and retry\r\n                            if (err.message?.includes('offline') && attempt < retries) {\r\n                                await new Promise(resolve => setTimeout(resolve, delay));\r\n                                delay *= 2; // Exponential backoff\r\n                            } else if (attempt === retries) {\r\n                                // Final attempt failed\r\n                                setError(err.message || 'Could not load profile');\r\n                            }\r\n                        }\r\n                    }\r\n                };\r\n\r\n                await fetchProfileWithRetry();\r\n            } else {\r\n                setUserProfile(null);\r\n            }\r\n\r\n            setLoading(false);\r\n        });\r\n\r\n        return () => unsubscribe();\r\n    }, []);\r\n\r\n    // Create user profile in Firestore\r\n    const createUserProfile = async (userId: string, data: Partial<UserProfile>) => {\r\n        const userRef = doc(db, 'users', userId);\r\n        await setDoc(userRef, {\r\n            ...data,\r\n            createdAt: serverTimestamp(),\r\n            consentGiven: false,\r\n            consentTimestamp: null,\r\n        });\r\n    };\r\n\r\n    // Sign up with email and password\r\n    const signUp = useCallback(async (email: string, password: string, displayName: string, role: 'senior' | 'relative') => {\r\n        setError(null);\r\n        try {\r\n            const { user: newUser } = await createUserWithEmailAndPassword(auth, email, password);\r\n\r\n            // Update display name\r\n            await updateProfile(newUser, { displayName });\r\n\r\n            // Create Firestore profile\r\n            const profileData: Partial<UserProfile> = {\r\n                email,\r\n                displayName,\r\n                role, // 'senior' or 'relative'\r\n            };\r\n            await createUserProfile(newUser.uid, profileData);\r\n\r\n            // Set userProfile immediately so consent flow works\r\n            setUserProfile({\r\n                email,\r\n                displayName,\r\n                role,\r\n                consentGiven: false,\r\n                consentTimestamp: null,\r\n                ...profileData\r\n            } as UserProfile);\r\n\r\n            return newUser;\r\n        } catch (err: any) {\r\n            setError(err.message);\r\n            throw err;\r\n        }\r\n    }, []);\r\n\r\n    // Sign in with email and password\r\n    const signIn = useCallback(async (email: string, password: string) => {\r\n        setError(null);\r\n        try {\r\n            const { user } = await signInWithEmailAndPassword(auth, email, password);\r\n            return user;\r\n        } catch (err: any) {\r\n            setError(err.message);\r\n            throw err;\r\n        }\r\n    }, []);\r\n\r\n    // Sign in with Google\r\n    const signInWithGoogle = useCallback(async (role: 'senior' | 'relative') => {\r\n        setError(null);\r\n        try {\r\n            const { user: googleUser } = await signInWithPopup(auth, googleProvider);\r\n\r\n            // Check if user profile exists, if not create one\r\n            const profileDoc = await getDoc(doc(db, 'users', googleUser.uid));\r\n            if (!profileDoc.exists()) {\r\n                await createUserProfile(googleUser.uid, {\r\n                    email: googleUser.email!,\r\n                    displayName: googleUser.displayName!,\r\n                    role,\r\n                });\r\n            }\r\n\r\n            return googleUser;\r\n        } catch (err: any) {\r\n            setError(err.message);\r\n            throw err;\r\n        }\r\n    }, []);\r\n\r\n    // Sign out\r\n    const signOut = useCallback(async () => {\r\n        setError(null);\r\n        try {\r\n            await firebaseSignOut(auth);\r\n        } catch (err: any) {\r\n            setError(err.message);\r\n            throw err;\r\n        }\r\n    }, []);\r\n\r\n    // Update user role\r\n    const updateRole = useCallback(async (role: 'senior' | 'relative') => {\r\n        if (!user) return;\r\n\r\n        try {\r\n            await setDoc(doc(db, 'users', user.uid), { role }, { merge: true });\r\n            setUserProfile(prev => prev ? ({ ...prev, role }) : null);\r\n        } catch (err: any) {\r\n            setError(err.message);\r\n            throw err;\r\n        }\r\n    }, [user]);\r\n\r\n    // Record consent\r\n    const recordConsent = useCallback(async () => {\r\n        if (!user) return;\r\n\r\n        try {\r\n            await setDoc(doc(db, 'users', user.uid), {\r\n                consentGiven: true,\r\n                consentTimestamp: serverTimestamp(),\r\n            }, { merge: true });\r\n            setUserProfile(prev => prev ? ({ ...prev, consentGiven: true }) : null);\r\n        } catch (err: any) {\r\n            setError(err.message);\r\n            throw err;\r\n        }\r\n    }, [user]);\r\n\r\n    // Update language preference\r\n    const updateLanguagePreference = useCallback(async (lang: string) => {\r\n        if (!user) return;\r\n\r\n        try {\r\n            await setDoc(doc(db, 'users', user.uid), {\r\n                languagePreference: lang,\r\n            }, { merge: true });\r\n            setUserProfile(prev => prev ? ({ ...prev, languagePreference: lang }) : null);\r\n        } catch (err: any) {\r\n            setError(err.message);\r\n            throw err;\r\n        }\r\n    }, [user]);\r\n\r\n    // Reset password\r\n    const resetPassword = useCallback(async (email: string) => {\r\n        setError(null);\r\n        try {\r\n            await sendPasswordResetEmail(auth, email);\r\n        } catch (err: any) {\r\n            setError(err.message);\r\n            throw err;\r\n        }\r\n    }, []);\r\n\r\n    return {\r\n        user,\r\n        userProfile,\r\n        loading,\r\n        error,\r\n        signUp,\r\n        signIn,\r\n        signInWithGoogle,\r\n        signOut,\r\n        updateRole,\r\n        recordConsent,\r\n        updateLanguagePreference,\r\n        resetPassword,\r\n        isAuthenticated: !!user,\r\n    };\r\n}\r\n\r\nexport default useAuth;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\dinko\\Projects\\PNWS\\tryg-app\\src\\hooks\\useCareCircle.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_userProfile' is defined but never used.","line":30,"column":59,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":71},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":51,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1730,1733],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1730,1733],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":57,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2133,2136],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2133,2136],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":79,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3086,3089],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3086,3089],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":160,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5841,5844],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5841,5844],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":202,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":202,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7313,7316],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7313,7316],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":234,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":234,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8366,8369],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8366,8369],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":248,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":248,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8899,8902],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8899,8902],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":262,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":262,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9483,9486],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9483,9486],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Care Circle hook - manages the shared family space\r\n// Handles creating circles, joining via code, and real-time membership\r\n\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport {\r\n    collection,\r\n    doc,\r\n    setDoc,\r\n    getDoc,\r\n    getDocs,\r\n    query,\r\n    where,\r\n    onSnapshot,\r\n    serverTimestamp,\r\n    deleteDoc\r\n} from 'firebase/firestore';\r\nimport { db } from '../config/firebase';\r\nimport { CareCircle, Member, UserProfile } from '../types';\r\n\r\n// Generate a random 6-character invite code\r\nconst generateInviteCode = () => {\r\n    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Removed confusing chars (0, O, I, 1)\r\n    let code = '';\r\n    for (let i = 0; i < 6; i++) {\r\n        code += chars.charAt(Math.floor(Math.random() * chars.length));\r\n    }\r\n    return code;\r\n};\r\n\r\nexport function useCareCircle(userId: string | undefined, _userProfile: UserProfile | null) {\r\n    const [careCircle, setCareCircle] = useState<CareCircle | null>(null);\r\n    const [members, setMembers] = useState<Member[]>([]);\r\n    const [loading, setLoading] = useState(true);\r\n    const [error, setError] = useState<string | null>(null);\r\n    const [inviteCode, setInviteCode] = useState<string | null>(null);\r\n\r\n    // Find user's care circle on mount\r\n    useEffect(() => {\r\n        if (!userId) {\r\n            setLoading(false);\r\n            return;\r\n        }\r\n\r\n        const findCareCircle = async () => {\r\n            try {\r\n                // Query for user's circle memberships\r\n                const membershipsQuery = query(\r\n                    collection(db, 'careCircleMemberships'),\r\n                    where('userId', '==', userId)\r\n                );\r\n                let membershipsSnapshot: any = await getDocs(membershipsQuery);\r\n\r\n                if (membershipsSnapshot.empty) {\r\n                    // FALLBACK: Fetch all and filter client-side (works around index issues)\r\n                    const allMembershipsSnapshot = await getDocs(collection(db, 'careCircleMemberships'));\r\n                    const matchingDocs = allMembershipsSnapshot.docs.filter(\r\n                        (doc: any) => doc.data().userId === userId\r\n                    );\r\n\r\n                    if (matchingDocs.length > 0) {\r\n                        membershipsSnapshot = {\r\n                            empty: false,\r\n                            docs: matchingDocs\r\n                        };\r\n                    }\r\n                }\r\n\r\n                if (!membershipsSnapshot.empty) {\r\n                    const membership = membershipsSnapshot.docs[0].data();\r\n                    const circleRef = doc(db, 'careCircles', membership.circleId);\r\n                    const circleDoc = await getDoc(circleRef);\r\n\r\n                    if (circleDoc.exists()) {\r\n                        setCareCircle({ id: circleDoc.id, ...circleDoc.data() } as CareCircle);\r\n                    } else {\r\n                        console.warn('[useCareCircle] Circle doc does not exist:', membership.circleId);\r\n                    }\r\n                }\r\n            } catch (err: any) {\r\n                console.error('[useCareCircle] Error finding care circle:', err);\r\n                // Check if it's a missing index error\r\n                if (err.message?.includes('index')) {\r\n                    setError('Database index mangler. Kontakt support.');\r\n                } else {\r\n                    setError(err.message);\r\n                }\r\n            } finally {\r\n                setLoading(false);\r\n            }\r\n        };\r\n\r\n        findCareCircle();\r\n    }, [userId]);\r\n\r\n    // Subscribe to members when we have a circle\r\n    useEffect(() => {\r\n        if (!careCircle?.id) return;\r\n\r\n        const membersQuery = query(\r\n            collection(db, 'careCircleMemberships'),\r\n            where('circleId', '==', careCircle.id)\r\n        );\r\n\r\n        const unsubscribe = onSnapshot(membersQuery, (snapshot) => {\r\n            const memberList = snapshot.docs.map(doc => ({\r\n                id: doc.id,\r\n                docId: doc.id, // Explicitly map docId for Member interface compliance\r\n                ...doc.data()\r\n            })) as Member[];\r\n            setMembers(memberList);\r\n        });\r\n\r\n        return () => unsubscribe();\r\n    }, [careCircle?.id]);\r\n\r\n    // Create a new care circle (for seniors)\r\n    const createCareCircle = useCallback(async (seniorName: string) => {\r\n        if (!userId) return;\r\n\r\n        try {\r\n            setError(null);\r\n            const newCode = generateInviteCode();\r\n            const circleId = `circle_${userId}_${Date.now()}`;\r\n\r\n            // Create the circle\r\n            await setDoc(doc(db, 'careCircles', circleId), {\r\n                seniorId: userId,\r\n                seniorName,\r\n                inviteCode: newCode,\r\n                createdAt: serverTimestamp(),\r\n            });\r\n\r\n            // Add senior as first member\r\n            await setDoc(doc(db, 'careCircleMemberships', `${circleId}_${userId}`), {\r\n                circleId,\r\n                userId,\r\n                displayName: seniorName,\r\n                role: 'senior',\r\n                joinedAt: serverTimestamp(),\r\n            });\r\n\r\n            // Initialize default settings\r\n            await setDoc(doc(db, 'careCircles', circleId, 'settings', 'main'), {\r\n                familyStatus: 'home',\r\n                lastUpdated: serverTimestamp(),\r\n            });\r\n\r\n            const newCircle: CareCircle = {\r\n                id: circleId,\r\n                seniorId: userId,\r\n                seniorName,\r\n                inviteCode: newCode,\r\n                createdAt: new Date().toISOString() // Approximate time for client immediately\r\n            }\r\n\r\n            setCareCircle(newCircle);\r\n            setInviteCode(newCode);\r\n\r\n            return circleId;\r\n        } catch (err: any) {\r\n            console.error('Error creating care circle:', err);\r\n            setError(err.message);\r\n            throw err;\r\n        }\r\n    }, [userId]);\r\n\r\n    // Join an existing care circle via invite code\r\n    const joinCareCircle = useCallback(async (code: string, displayName: string, relationship?: string) => {\r\n        if (!userId) return;\r\n\r\n        try {\r\n            setError(null);\r\n\r\n            // Find circle by invite code\r\n            const circlesQuery = query(\r\n                collection(db, 'careCircles'),\r\n                where('inviteCode', '==', code.toUpperCase())\r\n            );\r\n            const circlesSnapshot = await getDocs(circlesQuery);\r\n\r\n            if (circlesSnapshot.empty) {\r\n                throw new Error('Ugyldig invitationskode');\r\n            }\r\n\r\n            const circleDoc = circlesSnapshot.docs[0];\r\n            const circleId = circleDoc.id;\r\n            const circleData = circleDoc.data();\r\n\r\n            // Add user as member\r\n            await setDoc(doc(db, 'careCircleMemberships', `${circleId}_${userId}`), {\r\n                circleId,\r\n                userId,\r\n                displayName,\r\n                role: 'relative',\r\n                joinedAt: serverTimestamp(),\r\n                relationship: relationship || 'family' // Default if not provided\r\n            });\r\n\r\n            setCareCircle({ id: circleId, ...circleData } as CareCircle);\r\n\r\n            return circleId;\r\n        } catch (err: any) {\r\n            console.error('Error joining care circle:', err);\r\n            setError(err.message);\r\n            throw err;\r\n        }\r\n    }, [userId]);\r\n\r\n    // Get invite code for sharing\r\n    const getInviteCode = useCallback(async () => {\r\n        if (!careCircle?.id) return null;\r\n\r\n        try {\r\n            const circleDoc = await getDoc(doc(db, 'careCircles', careCircle.id));\r\n            if (circleDoc.exists()) {\r\n                const code = circleDoc.data().inviteCode;\r\n                setInviteCode(code);\r\n                return code;\r\n            }\r\n        } catch (err) {\r\n            console.error('Error getting invite code:', err);\r\n        }\r\n        return null;\r\n    }, [careCircle?.id]);\r\n\r\n    // Leave care circle\r\n    const leaveCareCircle = useCallback(async () => {\r\n        if (!careCircle?.id || !userId) return;\r\n\r\n        try {\r\n            await deleteDoc(doc(db, 'careCircleMemberships', `${careCircle.id}_${userId}`));\r\n            setCareCircle(null);\r\n            setMembers([]);\r\n        } catch (err: any) {\r\n            console.error('Error leaving care circle:', err);\r\n            setError(err.message);\r\n            throw err;\r\n        }\r\n    }, [careCircle?.id, userId]);\r\n\r\n    // Update member profile (Self)\r\n    const updateMember = useCallback(async (data: Partial<Member>) => {\r\n        if (!careCircle?.id || !userId) return;\r\n\r\n        try {\r\n            const memberRef = doc(db, 'careCircleMemberships', `${careCircle.id}_${userId}`);\r\n            await setDoc(memberRef, data, { merge: true });\r\n        } catch (err: any) {\r\n            console.error('Error updating member:', err);\r\n            throw err;\r\n        }\r\n    }, [careCircle?.id, userId]);\r\n\r\n    // Update ANY member (Admin Action) - Renaming/Relation changes\r\n    const updateMemberByDocId = useCallback(async (memberId: string, data: Partial<Member>) => {\r\n        if (!careCircle?.id) return;\r\n\r\n        try {\r\n            console.log(\"­ƒôØ Updating member:\", memberId, data);\r\n            const memberRef = doc(db, 'careCircleMemberships', memberId);\r\n            await setDoc(memberRef, data, { merge: true });\r\n        } catch (err: any) {\r\n            console.error('Error updating member (Admin):', err);\r\n            throw err;\r\n        }\r\n    }, [careCircle?.id]);\r\n\r\n    return {\r\n        careCircle,\r\n        members,\r\n        loading,\r\n        error,\r\n        inviteCode,\r\n        createCareCircle,\r\n        joinCareCircle,\r\n        getInviteCode,\r\n        leaveCareCircle,\r\n        updateMember,\r\n        updateAnyMember: updateMemberByDocId,\r\n        hasCareCircle: !!careCircle,\r\n    };\r\n}\r\n\r\nexport default useCareCircle;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\dinko\\Projects\\PNWS\\tryg-app\\src\\hooks\\useCheckIn.ts","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nC:\\Users\\dinko\\Projects\\PNWS\\tryg-app\\src\\hooks\\useCheckIn.ts:21:13\n  19 |     useEffect(() => {\n  20 |         if (!circleId) {\n> 21 |             setLastCheckIn(null);\n     |             ^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  22 |             setLoading(false);\n  23 |             return;\n  24 |         }","line":21,"column":13,"nodeType":null,"endLine":21,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2029,2032],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2029,2032],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":83,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2961,2964],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2961,2964],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Check-in hook - real-time sync via Firestore\r\n// Tracks when senior last checked in, visible to relatives\r\n\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport {\r\n    doc,\r\n    setDoc,\r\n    onSnapshot,\r\n    serverTimestamp\r\n} from 'firebase/firestore';\r\nimport { db } from '../config/firebase';\r\n\r\nexport function useCheckIn(circleId: string | undefined) {\r\n    const [lastCheckIn, setLastCheckIn] = useState<string | null>(null);\r\n    const [loading, setLoading] = useState(true);\r\n    const [error, setError] = useState<string | null>(null);\r\n\r\n    // Subscribe to check-in status from settings\r\n    useEffect(() => {\r\n        if (!circleId) {\r\n            setLastCheckIn(null);\r\n            setLoading(false);\r\n            return;\r\n        }\r\n\r\n        const checkInRef = doc(db, 'careCircles', circleId, 'settings', 'checkIn');\r\n\r\n        const unsubscribe = onSnapshot(checkInRef,\r\n            (snapshot) => {\r\n                if (snapshot.exists()) {\r\n                    const data = snapshot.data();\r\n                    if (data.lastCheckIn) {\r\n                        try {\r\n                            const date = data.lastCheckIn.toDate?.() || new Date(data.lastCheckIn);\r\n                            const timeString = date.toLocaleTimeString('da-DK', {\r\n                                hour: '2-digit',\r\n                                minute: '2-digit'\r\n                            });\r\n                            setLastCheckIn(timeString);\r\n                        } catch (err) {\r\n                            console.error('[useCheckIn] Error parsing timestamp:', err);\r\n                            setLastCheckIn(null);\r\n                        }\r\n                    } else {\r\n                        setLastCheckIn(null);\r\n                    }\r\n                } else {\r\n                    // Document doesn't exist yet - this is normal for new circles\r\n                    setLastCheckIn(null);\r\n                }\r\n                setLoading(false);\r\n            },\r\n            (err: any) => {\r\n                console.error('Error fetching check-in:', err);\r\n                setError(err.message);\r\n                setLoading(false);\r\n            }\r\n        );\r\n\r\n        return () => unsubscribe();\r\n    }, [circleId]);\r\n\r\n    // Record a check-in\r\n    const recordCheckIn = useCallback(async () => {\r\n        if (!circleId) return;\r\n\r\n        const checkInRef = doc(db, 'careCircles', circleId, 'settings', 'checkIn');\r\n\r\n        try {\r\n            await setDoc(checkInRef, {\r\n                lastCheckIn: serverTimestamp(),\r\n            }, { merge: true });\r\n\r\n            // Update local state immediately for responsive UI\r\n            const now = new Date();\r\n            const timeString = now.toLocaleTimeString('da-DK', {\r\n                hour: '2-digit',\r\n                minute: '2-digit'\r\n            });\r\n            setLastCheckIn(timeString);\r\n\r\n            return timeString;\r\n        } catch (err: any) {\r\n            console.error('Error recording check-in:', err);\r\n            setError(err.message);\r\n            throw err;\r\n        }\r\n    }, [circleId]);\r\n\r\n    return {\r\n        lastCheckIn,\r\n        loading,\r\n        error,\r\n        recordCheckIn,\r\n    };\r\n}\r\n\r\nexport default useCheckIn;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\dinko\\Projects\\PNWS\\tryg-app\\src\\hooks\\useCircadianTheme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\dinko\\Projects\\PNWS\\tryg-app\\src\\hooks\\useLocalStorage.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":11,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":15}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @ts-check\r\nimport { useState, useEffect } from 'react';\r\n\r\n// Check if localStorage is available (private browsing, quota exceeded, etc.)\r\nconst isLocalStorageAvailable = (): boolean => {\r\n    try {\r\n        const testKey = '__localStorage_test__';\r\n        window.localStorage.setItem(testKey, testKey);\r\n        window.localStorage.removeItem(testKey);\r\n        return true;\r\n    } catch (e) {\r\n        return false;\r\n    }\r\n};\r\n\r\nconst storageAvailable = isLocalStorageAvailable();\r\n\r\nexport function useLocalStorage<T>(key: string, initialValue: T): [T, (value: T | ((val: T) => T)) => void] {\r\n    // Get stored value or use initial\r\n    const [storedValue, setStoredValue] = useState<T>(() => {\r\n        if (!storageAvailable) {\r\n            console.warn('localStorage not available, using in-memory storage');\r\n            return initialValue;\r\n        }\r\n        try {\r\n            const item = window.localStorage.getItem(key);\r\n            return item ? JSON.parse(item) : initialValue;\r\n        } catch (error) {\r\n            console.warn(`Error reading localStorage key \"${key}\":`, error);\r\n            return initialValue;\r\n        }\r\n    });\r\n\r\n    // Update localStorage when value changes\r\n    useEffect(() => {\r\n        if (!storageAvailable) return; // Graceful degradation - just use state\r\n        try {\r\n            window.localStorage.setItem(key, JSON.stringify(storedValue));\r\n        } catch (error) {\r\n            console.warn(`Error setting localStorage key \"${key}\":`, error);\r\n        }\r\n    }, [key, storedValue]);\r\n\r\n    return [storedValue, setStoredValue];\r\n}\r\n\r\n// Named export for testing/util availability\r\nexport { isLocalStorageAvailable };\r\n\r\n// Default export for convenience\r\nexport default useLocalStorage;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\dinko\\Projects\\PNWS\\tryg-app\\src\\hooks\\useScrollLock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\dinko\\Projects\\PNWS\\tryg-app\\src\\hooks\\useSettings.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[368,371],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[368,371],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nC:\\Users\\dinko\\Projects\\PNWS\\tryg-app\\src\\hooks\\useSettings.ts:23:13\n  21 |     useEffect(() => {\n  22 |         if (!circleId) {\n> 23 |             setLoading(false);\n     |             ^^^^^^^^^^ Avoid calling setState() directly within an effect\n  24 |             return;\n  25 |         }\n  26 |","line":23,"column":13,"nodeType":null,"endLine":23,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":36,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1171,1174],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1171,1174],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":57,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1829,1832],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1829,1832],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":65,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2089,2092],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2089,2092],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":75,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2411,2414],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2411,2414],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Settings hook - real-time settings sync via Firestore\r\n// Handles family status and other circle-wide settings\r\n\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport { doc, setDoc, onSnapshot, serverTimestamp } from 'firebase/firestore';\r\nimport { db } from '../config/firebase';\r\n\r\ninterface Settings {\r\n    familyStatus: string;\r\n    [key: string]: any;\r\n}\r\n\r\nexport function useSettings(circleId: string | undefined) {\r\n    const [settings, setSettings] = useState<Settings>({\r\n        familyStatus: 'home',\r\n    });\r\n    const [loading, setLoading] = useState(true);\r\n    const [error, setError] = useState<string | null>(null);\r\n\r\n    // Subscribe to settings from Firestore\r\n    useEffect(() => {\r\n        if (!circleId) {\r\n            setLoading(false);\r\n            return;\r\n        }\r\n\r\n        const settingsRef = doc(db, 'careCircles', circleId, 'settings', 'main');\r\n\r\n        const unsubscribe = onSnapshot(settingsRef,\r\n            (docSnap) => {\r\n                if (docSnap.exists()) {\r\n                    setSettings(docSnap.data() as Settings);\r\n                }\r\n                setLoading(false);\r\n            },\r\n            (err: any) => {\r\n                console.error('Error fetching settings:', err);\r\n                setError(err.message);\r\n                setLoading(false);\r\n            }\r\n        );\r\n\r\n        return () => unsubscribe();\r\n    }, [circleId]);\r\n\r\n    // Update family status\r\n    const setFamilyStatus = useCallback(async (status: string) => {\r\n        if (!circleId) return;\r\n\r\n        const settingsRef = doc(db, 'careCircles', circleId, 'settings', 'main');\r\n\r\n        try {\r\n            await setDoc(settingsRef, {\r\n                familyStatus: status,\r\n                lastUpdated: serverTimestamp(),\r\n            }, { merge: true });\r\n        } catch (err: any) {\r\n            console.error('Error updating family status:', err);\r\n            setError(err.message);\r\n            throw err;\r\n        }\r\n    }, [circleId]);\r\n\r\n    // Update any setting\r\n    const updateSetting = useCallback(async (key: string, value: any) => {\r\n        if (!circleId) return;\r\n\r\n        const settingsRef = doc(db, 'careCircles', circleId, 'settings', 'main');\r\n\r\n        try {\r\n            await setDoc(settingsRef, {\r\n                [key]: value,\r\n                lastUpdated: serverTimestamp(),\r\n            }, { merge: true });\r\n        } catch (err: any) {\r\n            console.error('Error updating setting:', err);\r\n            setError(err.message);\r\n            throw err;\r\n        }\r\n    }, [circleId]);\r\n\r\n    return {\r\n        settings,\r\n        familyStatus: settings.familyStatus,\r\n        loading,\r\n        error,\r\n        setFamilyStatus,\r\n        updateSetting,\r\n    };\r\n}\r\n\r\nexport default useSettings;\r\n","usedDeprecatedRules":[]}]
